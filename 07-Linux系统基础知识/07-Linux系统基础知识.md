# Linux知识补充(更新时间: 2021-7-22 20:12)
## tail命令
```text
从文件尾部向上查看最后n行的内容
使用方式：tail -n[行数] 文件名
如果没有指定行数，默认显示最后10行内容
*****
一个比较重要的应用：显示日志 : tail -f test.log
一个终端tail -f test.log , 另一个终端: echo “hello world” >>test.log
*****
```
## 软链接 -- 源文件要使用绝对路径
```text
* 软连接类似于windows下的快捷方式

* 如何创建软连接:
ln -s 文件名 快捷方式的名字
例如：ln -s aa aa.soft

目录也可以创建软连接
例如：ln -s tmp tmp.link

*****
创建软链接应注意事项:
ln创建软连接要用绝对路径，因为如果不使用绝对路径，一旦这个连接文件发生位置变动，就不能找到那个文件了。（如果使用相对路径软连接或者原文件移动位置都找不到了）

软连接文件的大小是: 路径+文件名的总字节数
```
## 硬链接
```text
* ln 文件名 硬链接的名字
* ln test.log test.log.hard
* 使用硬链接应注意事项
* 硬链接不能建在目录上  目录不能建立硬链接
* 硬连接对绝对路径没有要求
* 硬连接不能跨文件系统

硬链接文件和源文件的inode是相同的，文件系统的inode要求唯一，跨文件系统可能会使inode不同, 所以硬链接不能跨文件系统

* 硬链接的本质
* 硬连接的本质是不同的文件名所在的inode节点是相同的，相同的inode节点指向了相同的数据块，所以他们的文件内容是一样的，文件内容会同步。
```
## 软件的安装和卸载
```text
11.1 在线安装 -- 建议安装前update下
	软件安装：sudo apt-get install 软件名
	软件卸载：sudo apt-get remove 软件名
	更新软件列表：sudo apt-get update
	清理安装包：sudo apt-get clean
	清理的是缓存路径：/var/cache/apt/archives

11.2 软件包安装
	在Ubuntu系统下必须有deb格式的安装包
	软件安装
	sudo dpkg -i xxx.deb
	软件卸载
	sudo dpkg -r 软件名
```



# VIM
## 命令模式下的操作
### 保存退出
| 快捷键 | 操作 |
| :---: | :---:|
| ZZ | 保存退出|

### 代码格式化
| 快捷键 | 操作 |
| :---: | :---: |
| gg=G | 代码的格式化 |

### 光标移动(键盘上下左右键课代替)
| 快捷键 | 操作 |
| :---: | :---: |
| h | 光标左移 |
| j | 光标下移 |
| k | 光标上移 |
| l | 光标右移 |
| w | 移动一个单词 |
| gg | ***光标移动到文件开头*** |
| G | ***光标移动到文件末尾*** |
| 0/Home | **光标移到到行首** |
| $/End | **光标移到到行尾** |
| nG | **行跳转, 例12G, 跳到12行处** |



### 删除命令
| 快捷键 | 操作 |
| :---: | :---: |
| **x** | 删除光标后一个字符,相当于 Del |
|  X | 删除光标前一个字符,相当于 Backspace |
| dw | 删除光标开始位置的字,包含光标所在字符 |
| d0 | 删除光标前本行所有内容,不包含光标所在字符 |
| D[d$] | 删除光标后本行所有内容,包含光标所在字符 |
| **dd** | 删除光标所在行(本质其实是剪切) |
| **ndd** | 从光标当前行向下删除指定的行数, 如15dd |
| **v/ctrl+v** | 使用h、j、k、l移动选择内容, 然后按d删除其中ctrl+v是列模式, v为非列模式 |

### 撤销和反撤销命令
| 快捷键 | 操作 |
| :---: | :---: |
| **u** | 一步一步撤销, 相当于word文档的ctrl+z |
| ctrl-r | 反撤销, 相当于word文档的ctrl+y |


### 复制粘贴
| 快捷键 | 操作 |
| :---: | :---: |
| **yy** | 复制当前行 |
| **nyy** | 复制n行, 如10yy |
| **p** | 在光标所在位置向下新开辟一行, 粘贴 |
| P | 在光标所在位置向上新开辟一行, 粘贴 |
| 剪切操作 | 按dd或者ndd删除, 将删除的行保存到剪贴板中, 然后按p/P就可以粘贴了 |

### 可视模式
| 快捷键 | 操作 |
| :---: | :---: |
| v/ctrl+v | 使用h、j、k、l移动选择内容;使用d删除使用y复制使用粘贴到光标的后面使用P(大写)粘贴到光标的前面 |


### 查找命令
| 快捷键 | 操作 |
| :---: | :---: |
| **/** | /xxxx, 从光标所在的位置开始搜索, 按n向下搜索, 按N向上搜索 |
| ? | ?xxxx, 从光标所在的位置开始搜索, 按n向上搜索, 按N向下搜索 |
| # | 将光标移动到待搜索的字符串上, 然后按n向上搜索,但N向下搜索 |
| shift+k | 在待搜索的字符串上按shift+k或者K, 可以查看相关的帮助文档 |

## 切换到文本输入模式
### 从命令模式切换到文本输入模式只需输入如下命令
| 快捷键 | 操作 |
| :---: | :---: |
| ***i*** | 在光标前插入 |
| a | 在光标后插入 |
| I | 在光标所在行的行首插入 |
| A | 在光标所在行的行尾插入 |
| o | 在光标所在的行的下面新创建一行, 行首插入|
| O | 在光标所在的行的上面新创建一行, 行首插入 |
| s | 删除光标后边的字符, 从光标当前位置插入 |
| S | 删除光标所在当前行, 从行首插入 |
| **按列模式插入** | 先按ctrl+v进入列模式, 按hjkl移动选定某列,按I或者shift+i向前插入, 然后插入字符, 最后按两次esc. |

## 末行模式下的操作
### 从命令模式切换到末行模式, 输入冒号(:)
| 快捷键 | 操作 |
| :---: | :---: |
| q | 退出 |
| q! | 强制退出，不保存修改内容 |
| w | 保存修改内容, 不退出 |
| wq | 保存并退出 |
| x | 相当于wq |

### 替换操作
| 快捷键 | 操作 |
| :---: | :---: |
| :s/old/new/ | 光标所在行的第一个old替换为new |
| :s/old/new/g | 光标所在行的所有old替换为new |
| :m,ns/old/new/g | 将第m行至第n行之间的old全部替换成new |
| :%s/old/new/g | 当前文件的所有old替换为new |
| :1,$s/old/new/g | 当前文件的所有old替换为new |
| :%s/old/new/gc | 同上，但是每次替换需要用户确认 |



### 快速翻屏
| 快捷键 | 操作 |
| :---: | :---: |
| ctrl + u | 向下翻半屏(up)--光标向上移动 |
| ctrl + d | 向上翻半屏(down)--光标向下移动 |
| ctrl + f | 向上翻一屏(front) |
| ctrl + b | 向后翻一屏(back) |

### 分屏操作
| 快捷键 | 操作 |
| :---: | :---: |
| sp | 当前文件水平分屏 |
| vsp | 当前文件垂直分屏 |
| sp 文件名 | 当前文件和另一个文件水平分屏 |
| vsp 文件名 | 当前文件和另一个文件垂直分屏 |
| ctrl-w-w | 在多个窗口切换光标 |
| wall/wqall/xall/qall/qall! | 保存/保存退出/保存退出/退出/强制退出分屏窗口 |


# gcc编译器
## gcc的工作流程:见下图
### 光标移动(键盘上下左右键课代替)
| 快捷键 | 操作 |
| :---: | :---: |
| -V | 查看gcc版本号, --version也可以 |
| -E | 生成预处理文件 |
| -S | 生成汇编文件 |
| **-c** | 只编译, 生成.o文件, 通常称为目标文件|
| **-I** | 指定头文件所在的路径 |
| **-L** | 指定库文件所在的路径 |
| **-l** | 指定库的名字 |
| **-o** | 指定生成的目标文件的名字 |
| **-g** | 包含调试信息, 使用gdb调试需要添加-g参数 |
| -On | n=0∼3 编译优化,n越大优化得越多 |
| -Wall | 提示更多警告信息 |
| -D | 编译时定义宏 |
```c
//test.c文件中的代码片段: 
printf("MAX==[%d]\n", MAX);
         编译: 
    	gcc -o test test.c -D MAX=10
        gcc -o test test.c -DMAX=10
```
# 静态库（static library）
| a | b |
| :---: | :---: |
| 前缀 | lib |
| 库名称 | 自定义即可, 如test |
| 后缀 | .a |
## 静态库的制作
```text
下面以fun1.c , fun2.c和head.h三个文件为例讲述静态库的制作和使用, 其中head.h文件中有函数的声明,  fun1.c和fun2.c中有函数的实现
```
### 步骤1：将c源文件生成对应的.o文件
```
gcc -c fun1.c fun2.c

或者分别生成.o文件:
 	gcc -c fun1.c -o fun1.o    （后面的-o fun1.o可用省略）
 	gcc -c fun2.c -o fun2.o
 ```
### 步骤2：使用打包工具ar将准备好的.o文件打包为.a文件
```
在使用ar工具是时候需要添加参数rcs
    r更新、c创建、s建立索引
命令：ar rcs 静态库名 .o文件
    ar rcs libtest1.a fun1.o fun2.o
```
## 静态库的使用
```text
静态库制作完成之后, 需要将.a文件和头文件一定发布给用户.
假设测试文件为main.c, 静态库文件为libtest1.a, 头文件为head.h
用到的参数：
*	-L：指定要连接的库的所在目录
*	-l：指定链接时需要的静态库, 去掉前缀和后缀
*	-I: 指定main.c文件用到的头文件head.h所在的路径
gcc -o main1 main.c -L./ -ltest1 -I./
```
# 共享库（shared library）/动态库
```text
*	前缀：lib
*	库名称：自己定义即可, 如test
*	后缀：.so
所以最终的静态库的名字应该为：libtest.so
```
## 共享库的制作
###  1.	生成目标文件.o, 此时要加编译选项：-fPIC（fpic）
```text
gcc -fpic -c fun1.c fun2.c
参数：-fpic创建与地址无关的编译程序(pic, position independent code), 目的就是为了能够在多个应用程序间共享.
```
### 2.	生成共享库, 此时要加链接器选项: -shared（指定生成动态链接库）
```text
gcc -shared fun1.o fun2.o -o libtest2.so

// 查看libtest2.so中有哪些文件: nm libtest2.so
```
## 共享库的使用
```text
引用动态库编译成可执行文件（跟静态库方式一样）：
用到的参数：
*	-L：指定要连接的库的所在目录
*	-l：指定链接时需要的动态库, 去掉前缀和后缀
*	-I: 指定main.c文件用到的头文件head.h所在的路径
gcc main.c -I./ -L./ -ltest2 -o main2
```
## tips
+ 最后运行动态库是需要将.so文件放入lib文件夹下
(lib文件夹已经在用户目录配好环境)







